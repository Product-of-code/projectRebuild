<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=no"
    />
    <title>Uchiha Hyperdrive | Final</title>
    <style>
      body,
      html {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        background: #000;
        overflow: hidden;
        touch-action: none;
      }
      #canvas-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        z-index: 1;
      }

      .ui {
        position: absolute;
        z-index: 10;
        width: 100%;
        height: 100%;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        pointer-events: none;
        color: white;
        font-family: "Segoe UI", Tahoma, sans-serif;
        text-align: center;
      }

      h1 {
        font-size: clamp(2rem, 8vw, 5rem);
        margin: 0;
        letter-spacing: 15px;
        color: #ff0033;
        text-shadow: 0 0 20px #ff0033;
        font-weight: 900;
        text-transform: uppercase;
      }
      p {
        opacity: 0.5;
        letter-spacing: 3px;
        margin-top: 10px;
        font-size: 0.8rem;
      }
    </style>
  </head>
  <body>
    <div class="ui">
      <h1>Warp Drive</h1>
      <p>TAP TO DISCHARGE // SWIPE TO STEER</p>
    </div>

    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
      // --- 1. ENGINE SETUP ---
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000,
      );
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // High-DPI for Surface
      document
        .getElementById("canvas-container")
        .appendChild(renderer.domElement);

      // --- 2. MOTION BLUR PARTICLES ---
      const count = 2500;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(count * 3 * 2);
      const colors = new Float32Array(count * 3 * 2);

      for (let i = 0; i < count; i++) {
        const x = (Math.random() - 0.5) * 40;
        const y = (Math.random() - 0.5) * 40;
        const z = (Math.random() - 0.5) * 100;

        const idx = i * 6;
        // Head
        positions[idx] = x;
        positions[idx + 1] = y;
        positions[idx + 2] = z;
        // Tail
        positions[idx + 3] = x;
        positions[idx + 4] = y;
        positions[idx + 5] = z - 1;

        const color = new THREE.Color().setHSL(
          Math.random() * 0.1 + 0.95,
          1,
          0.5,
        ); // Deep reds
        colors[idx] = color.r;
        colors[idx + 1] = color.g;
        colors[idx + 2] = color.b;
        colors[idx + 3] = color.r;
        colors[idx + 4] = color.g;
        colors[idx + 5] = color.b;
      }

      geometry.setAttribute(
        "position",
        new THREE.BufferAttribute(positions, 3),
      );
      geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

      const material = new THREE.LineBasicMaterial({
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        transparent: true,
        opacity: 0.7,
      });

      const lines = new THREE.LineSegments(geometry, material);
      scene.add(lines);

      camera.position.z = 5;

      // --- 3. INTERACTION & FX STATE ---
      let mouseX = 0,
        mouseY = 0,
        isTouching = false;
      let flashIntensity = 0;
      let shakeStrength = 0;

      window.addEventListener("pointerdown", (e) => {
        isTouching = true;
        flashIntensity = 1.0;
        shakeStrength = 0.4;
        updateCoords(e);
      });

      window.addEventListener("pointerup", () => (isTouching = false));
      window.addEventListener("pointermove", (e) => updateCoords(e));

      function updateCoords(e) {
        mouseX = (e.clientX / window.innerWidth - 0.5) * 20;
        mouseY = (e.clientY / window.innerHeight - 0.5) * -20;
      }

      // --- 4. ANIMATION LOOP ---
      function animate() {
        requestAnimationFrame(animate);
        const posArr = geometry.attributes.position.array;
        const speed = isTouching ? 1.8 : 0.6;

        for (let i = 0; i < count; i++) {
          const idx = i * 6;
          // Forward movement
          posArr[idx + 2] += speed;
          // Tail stretching (Motion Blur)
          posArr[idx + 5] = posArr[idx + 2] - speed * 5;

          // Pull toward touch
          if (isTouching) {
            posArr[idx] += (mouseX - posArr[idx]) * 0.08;
            posArr[idx + 1] += (mouseY - posArr[idx + 1]) * 0.08;
            posArr[idx + 3] += (posArr[idx] - posArr[idx + 3]) * 0.4; // Tail lag
            posArr[idx + 4] += (posArr[idx + 1] - posArr[idx + 4]) * 0.4;
          }

          // Infinite Reset Loop
          if (posArr[idx + 2] > 10) {
            posArr[idx + 2] = -90;
            posArr[idx + 5] = -91;
            // Randomize reposition for variety
            posArr[idx] = (Math.random() - 0.5) * 40;
            posArr[idx + 1] = (Math.random() - 0.5) * 40;
            posArr[idx + 3] = posArr[idx];
            posArr[idx + 4] = posArr[idx + 1];
          }
        }
        geometry.attributes.position.needsUpdate = true;

        // Flash & Shake Decay
        if (flashIntensity > 0) flashIntensity *= 0.93;
        if (shakeStrength > 0) shakeStrength *= 0.9;

        // Apply FX
        renderer.setClearColor(
          new THREE.Color(flashIntensity * 0.4, 0, flashIntensity * 0.1),
        );

        camera.position.x +=
          (mouseX * 0.15 - camera.position.x) * 0.05 +
          (Math.random() - 0.5) * shakeStrength;
        camera.position.y +=
          (mouseY * 0.15 - camera.position.y) * 0.05 +
          (Math.random() - 0.5) * shakeStrength;
        camera.lookAt(0, 0, -20);

        renderer.render(scene, camera);
      }

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      animate();
    </script>
  </body>
</html>

